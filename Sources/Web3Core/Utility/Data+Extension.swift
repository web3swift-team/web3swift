//
//  Created by Alex Vlasov.
//  Copyright Â© 2018 Alex Vlasov. All rights reserved.
//

import Foundation


extension Data {
    init<T>(fromArray values: [T]) {
        let values = values
        let ptrUB = values.withUnsafeBufferPointer { (ptr: UnsafeBufferPointer) in return ptr }
        self.init(buffer: ptrUB)
    }

    func toArray<T>(type: T.Type) throws -> [T] {
        return try self.withUnsafeBytes { (body: UnsafeRawBufferPointer) in
            if let bodyAddress = body.baseAddress, body.count > 0 {
                let pointer = bodyAddress.assumingMemoryBound(to: T.self)
                return [T](UnsafeBufferPointer(start: pointer, count: self.count/MemoryLayout<T>.stride))
            } else {
                throw Web3Error.dataError
            }
        }
    }

    func constantTimeComparisonTo(_ other: Data?) -> Bool {
        guard let rhs = other else {return false}
        guard self.count == rhs.count else {return false}
        var difference = UInt8(0x00)
        for i in 0..<self.count { // compare full length
            difference |= self[i] ^ rhs[i] // constant time
        }
        return difference == UInt8(0x00)
    }

    public static func zero(_ data: inout Data) {
        let count = data.count
        data.withUnsafeMutableBytes { (body: UnsafeMutableRawBufferPointer) in
            body.baseAddress?.assumingMemoryBound(to: UInt8.self).initialize(repeating: 0, count: count)
        }
    }

    @available(*, deprecated, message: "Please, use throwing `randomBytes(count)` function instead to get information instead of `nil` value on why the function call failed.")
    /// Runs `SecRandomCopyBytes` for Apple platforms and `openssl rand -hex` for other platforms
    /// to generate cryptographically secure random bytes.
    /// - Parameter count: how many bytes to generate. Value below or equal to 0 will return `nil`.
    /// - Returns: random bytes or `nil`.
    public static func randomBytes(length: Int) -> Data? {
        try? randomBytes(count: length)
    }

    /// Runs `SecRandomCopyBytes` for Apple platforms and `openssl rand -hex` for other platforms
    /// to generate cryptographically secure random bytes.
    /// - Parameter count: how many bytes to generate. Value below or equal to 0 will throw an error.
    /// - Parameter useOpenSSL: **has no effect on Linux and Windows**. When set to `true` forces the use of external executable `openssl`. It's your responsibility to make sure openssl is installed on this machine. By default set to `false`. To install follow [the official guide](https://www.openssl.org/source/ ).
    /// - Returns: random bytes or throws an error,
    public static func randomBytes(count: Int, useOpenSSL: Bool = false) throws -> Data {
        guard count > 0 else { throw Web3Error.valueError(desc: "Cannot generate \(count) random bytes.") }

        #if !(os(Linux) || os(Windows))
        if !useOpenSSL {
            for _ in 0...1024 {
                var data = Data(repeating: 0, count: count)
                let result = try data.withUnsafeMutableBytes { (body: UnsafeMutableRawBufferPointer) -> Int32? in
                    guard let bodyAddress = body.baseAddress, body.count == count else {
                        throw Web3Error.processingError(desc: "Address of the buffer is nil (\(body.baseAddress == nil)) or the count of bytes in the buffer is not equal to the count requested by the user (\(body.count < count)).")
                    }

                    let pointer = bodyAddress.assumingMemoryBound(to: UInt8.self)
                    return SecRandomCopyBytes(kSecRandomDefault, count, pointer)
                }
                if let notNilResult = result, notNilResult == errSecSuccess {
                    return data
                }
            }
        }
        #endif
        let randomBytesHex = try ShellCommandExecutor().run(commandName: "openssl rand -hex \(count)")
        guard let bytes = Data.fromHex(randomBytesHex) else {
            throw Web3Error.processingError(desc: "Random bytes generated by the openssl are in an invalid hex representation: \(randomBytesHex)")
        }

        guard bytes.count == count else {
            throw Web3Error.processingError(desc: "Count of generated by the openssl random bytes is not equal to the count requested by the user: expected \(count), given \(bytes.count).")
        }

        return bytes
    }

    public func bitsInRange(_ startingBit: Int, _ length: Int) -> UInt64? { // return max of 8 bytes for simplicity, non-public
        if startingBit + length / 8 > self.count, length > 64, startingBit > 0, length >= 1 { return nil }
        let bytes = self[(startingBit/8) ..< (startingBit+length+7)/8]
        let padding = Data(repeating: 0, count: 8 - bytes.count)
        let padded = bytes + padding
        guard padded.count == 8 else { return nil }
        let pointee = padded.withUnsafeBytes { (body: UnsafeRawBufferPointer) in
            body.baseAddress?.assumingMemoryBound(to: UInt64.self).pointee
        }
        guard let ptee = pointee else { return nil }
        var uintRepresentation = UInt64(bigEndian: ptee)
        uintRepresentation = uintRepresentation << (startingBit % 8)
        uintRepresentation = uintRepresentation >> UInt64(64 - length)
        return uintRepresentation
    }
}
